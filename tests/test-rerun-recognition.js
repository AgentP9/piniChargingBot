#!/usr/bin/env node

/**
 * Test for "rerun recognition" preserving manually assigned device names
 * 
 * This test simulates the scenario where:
 * 1. User manually assigns device names to processes
 * 2. User runs "rerun recognition" which clears all patterns
 * 3. The manually assigned names should be preserved in the new patterns
 */

const patternAnalyzer = require('../backend/patternAnalyzer.js');

console.log('Rerun Recognition with Manual Names Test');
console.log('=========================================\n');

// Create processes with manually assigned device names
const processWithManualName1 = {
  id: 1,
  chargerId: 'charger1',
  chargerName: 'Office Charger',
  deviceName: "Alice's iPhone", // Manually assigned (different from charger name)
  startTime: new Date('2026-01-01T10:00:00Z').toISOString(),
  endTime: new Date('2026-01-01T12:00:00Z').toISOString(),
  events: [
    { timestamp: new Date('2026-01-01T10:00:00Z').toISOString(), type: 'power_consumption', value: 15 },
    { timestamp: new Date('2026-01-01T10:30:00Z').toISOString(), type: 'power_consumption', value: 12 },
    { timestamp: new Date('2026-01-01T11:00:00Z').toISOString(), type: 'power_consumption', value: 10 },
    { timestamp: new Date('2026-01-01T11:30:00Z').toISOString(), type: 'power_consumption', value: 8 }
  ]
};

const processWithManualName2 = {
  id: 2,
  chargerId: 'charger1',
  chargerName: 'Office Charger',
  deviceName: "Alice's iPhone", // Same manual name (same device)
  startTime: new Date('2026-01-02T10:00:00Z').toISOString(),
  endTime: new Date('2026-01-02T12:00:00Z').toISOString(),
  events: [
    { timestamp: new Date('2026-01-02T10:00:00Z').toISOString(), type: 'power_consumption', value: 14 },
    { timestamp: new Date('2026-01-02T10:30:00Z').toISOString(), type: 'power_consumption', value: 11 },
    { timestamp: new Date('2026-01-02T11:00:00Z').toISOString(), type: 'power_consumption', value: 9 },
    { timestamp: new Date('2026-01-02T11:30:00Z').toISOString(), type: 'power_consumption', value: 7 }
  ]
};

const processWithoutManualName = {
  id: 3,
  chargerId: 'charger1',
  chargerName: 'Office Charger',
  deviceName: 'Office Charger', // Not manually assigned (same as charger name)
  startTime: new Date('2026-01-03T10:00:00Z').toISOString(),
  endTime: new Date('2026-01-03T12:00:00Z').toISOString(),
  events: [
    { timestamp: new Date('2026-01-03T10:00:00Z').toISOString(), type: 'power_consumption', value: 5 },
    { timestamp: new Date('2026-01-03T10:30:00Z').toISOString(), type: 'power_consumption', value: 5.5 },
    { timestamp: new Date('2026-01-03T11:00:00Z').toISOString(), type: 'power_consumption', value: 5.2 },
    { timestamp: new Date('2026-01-03T11:30:00Z').toISOString(), type: 'power_consumption', value: 5 }
  ]
};

const allProcesses = [processWithManualName1, processWithManualName2, processWithoutManualName];

console.log('Scenario: User manually assigns names, then runs "rerun recognition"');
console.log('---------------------------------------------------------------------\n');

console.log('Step 1: Processes with manual device names');
console.log(`  Process 1: deviceName="${processWithManualName1.deviceName}" (manual)`);
console.log(`  Process 2: deviceName="${processWithManualName2.deviceName}" (manual)`);
console.log(`  Process 3: deviceName="${processWithoutManualName.deviceName}" (not manual - same as charger)`);

console.log('\nStep 2: Simulate "rerun recognition" (empty existing patterns array)');
const patterns = patternAnalyzer.analyzePatterns(allProcesses, []);

console.log(`\nStep 3: Check resulting patterns`);
console.log(`  Found ${patterns.length} pattern(s)`);

let testPassed = true;
let manualNamePreserved = false;
let autoGeneratedForNonManual = false;

patterns.forEach((p, i) => {
  console.log(`\n  Pattern ${i + 1}:`);
  console.log(`    Device Name: "${p.deviceName}"`);
  console.log(`    Processes: [${p.processIds.join(', ')}]`);
  
  // Check if pattern with processes 1 and 2 has the manual name
  if (p.processIds.includes(1) && p.processIds.includes(2)) {
    if (p.deviceName === "Alice's iPhone") {
      manualNamePreserved = true;
      console.log(`    ✓ Manual name "Alice's iPhone" was preserved!`);
    } else {
      console.log(`    ✗ Expected "Alice's iPhone", got "${p.deviceName}"`);
    }
  }
  
  // Check if pattern with process 3 has an auto-generated name
  if (p.processIds.includes(3) && !p.processIds.includes(1) && !p.processIds.includes(2)) {
    if (p.deviceName === 'Hugo' || p.deviceName === 'Egon' || p.deviceName === 'Tom') {
      autoGeneratedForNonManual = true;
      console.log(`    ✓ Auto-generated name "${p.deviceName}" for process without manual name`);
    } else {
      console.log(`    ? Got name "${p.deviceName}" for process without manual name`);
      // This could be acceptable if it's the charger name
      if (p.deviceName === 'Office Charger') {
        console.log(`    Note: Pattern has charger name, not auto-generated`);
      }
    }
  }
});

// The key requirement is that manually assigned names are preserved
testPassed = manualNamePreserved;

console.log(`\n${'='.repeat(70)}`);
console.log(`Test Result: ${testPassed ? 'PASSED ✓' : 'FAILED ✗'}`);

if (testPassed) {
  console.log('✓ Manually assigned device names are preserved during "rerun recognition"');
  console.log('✓ This fixes the issue where manual work was lost');
} else {
  console.log('✗ Manually assigned device names were not preserved');
  console.log('✗ The "rerun recognition" bug is not fixed');
}

process.exit(testPassed ? 0 : 1);
